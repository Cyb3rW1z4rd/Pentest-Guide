# 05 - Network

## Network basics <a id="16-network-basics"></a>

If you use standard desktop installation for Ubuntu or Debian you get NetworkManager included, which handles your network connections, wire and wireless. NetworkManager is made to be easy to use, and "just work". And most of the time it does. But sometimes when you want to configure stuff on your own, for whatever reason, it can be a hassle. So for the rest of this chapter I am just going to assume that you have stopped, removed or disabled NetworkManager.

```text
# Stop NetworkManager
sudo systemctl stop NetworkManager.service

# Start NetworkManager
sudo systemctl start NetworkManager.service

# Disable it so it won't start at boot
sudo systemctl disable NetworkManager

#Enable it so it will start at boot
sudo systemctl disable NetworkManager
```

Network cards \(NIC\) are identified by their mac address, hosts by theirip address andapplications by their port number.

### In a nutshell what you need to know <a id="in-a-nutshell-what-you-need-to-know"></a>

Things you really need to know are:

```text
# Configuration files
/etc/network/interfaces
/etc/resolve.config

# Tools
ip
ip route
ifconfig
dhclient
wpa_supplicant
iptables
netstat
dnsmasq
```

### Configure Network Interface Cards \(NIC\) <a id="configure-network-interface-cards-nic"></a>

On debian NIC:s are defined and configured in`/etc/network/interfaces`.

```text
# automatically start eth0 on boot
auto eth0
# give the eth0 an ip through dhcp
iface eth0 inet dhcp

# start up the loopback interface
auto lo 
iface lo inet loopback


# A bridge called br1 - can be called  whatever.
# This bridge has a static ip
auto br1
iface br1 inet static
    address 192.168.55.1
    netmask 255.255.255.0
    broadcast 192.168.55.255
    bridge_ports none
```

**Take a interface up and down / start and stop**

It is recommended to take a interface down before configuring it.

```text
#
ifup eth0
ifdown eth0

# You can also use ip 
sudo ip link set dev eth0 down 
sudo ip link set dev eth0 down

# You can also use ifconfig to bring an interface up and down. The difference is that ifconfig 
# will use the current configuration, and not take into account changes from /etc/network/interfaces.
# So use ifup and ifdown!
ifconfig eth0 up
ifconfig eth0 down
```

**Configure an interface with ip or ifconfig**

If you want to configure an interface only temporarly you can use`ip`and`ifconfig`. The changes will not survive a reboot.

`Ifconfig`is old and deprecated on some systems. So use`ip`instead. But they do basically the same thing.

### Route <a id="route"></a>

Where packets are send in a network depends on the routing of the routing. Every node that the packet passes in its travel to its destination has a routing table defined, that says where the packet should be directed next. The most simple example is how the traffic of a home network is sent to the router, and then from there forwarded on to somewhere else on the internet. How every host should forward the packets are defined in the linux kernel routing table. You can see the routing table by running this command:

```text
route -n
ip route
netstat -r
```

I think that the most useful of these commands is route, since it includes the column names of the table. Here is an example of the output:

```text
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         192.168.55.1    0.0.0.0         UG    0      0        0 ens3
192.168.55.0    0.0.0.0         255.255.255.0   U     0      0        0 ens3
```

So let's image that we don't have any routing rules at all. It is completely empty. Like this:

```text
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
```

But we have network interface connected, called eth0. If we now try to ping the router \(the gateway\) on the network, we get this result:

```text
~ ping 192.168.55.1
connect: Network is unreachable
```

At this point we can't even add a route to the gateway. Because the network is unreacheable. So we need to hook outselfs up to the network first.

```text
route add -net 192.168.55.0 netmask 255.255.255.0 dev eth0
ip route add 192.168.55.0/24 via 10.175.34.1
```

Now our table looks like this:

```text
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.55.0    0.0.0.0         255.255.255.0   U     0      0        0 eth0
```

We still can't ping anything out in the internetz- That's because we are not reaching our gateway \(router\), since we haven't configured it yet.

```text
route add default gw 192.168.55.1 or ip route add default via 192.168.55.1
```

Remember that these routes will only be temporary.+

#### Example - Man in the middle a host <a id="example---man-in-the-middle-a-host"></a>

It is often useful to man in the middle all traffic from a machine, to see what requests and stuff it does.

Let's say that the scenario is that the victim-machine is connected to the mitm-machine by ethernet cable. This can be either a physical cable or thought a virtual machine.

**Victim machine**

On the victim machine we don't have network-manager installed. And out`/etc/network/interfaces`has nothing in it except for:

```text
auto lo
iface lo inet loopback
```

When we run`ip addr`we get the following result:

```text
root@deb64:~# ip a 1: lo: < LOOPBACK,UP,LOWER_UP >
 mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens3: <BROADCAST,MULTICAST>
 mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000
    link/ether 52:54:00:a9:fc:4a brd ff:ff:ff:ff:ff:ff
```

So our network interface ens3 does not have an ip-address and it is down. So let's first give it an ip-address, now remember that this ip-address will only be temporary, and will disappear on next reboot. If you want to make it permanent you need to define it in`/etc/network/interface`

**Give interface an ip-address**

```text
ip addr add 192.168.150.2/24 dev ens3

# Here we give it the ip-address 192.168.150.2 with netmask 255.255.255.0 (/24), and we 
# give it to the device/interface ens3
```

**Now we can start the interface, or "bring it up" as it is called:**

```text
ip link set ens3 up

# ifup and ifdown will not work
```

When we bring up the interface the routing table will automatically get populated.

```text
root@deb64:~# ip r
192.168.150.0/24 dev ens3 proto kernel scope link src 192.168.150.2
```

**Add default gateway**

But we are still not able to reach the internet since we have not defined a default gateway yet. So let's do that.

```text
ip route add default via 192.168.150.1 dev ens3
```

If we look at the routing table now we can see our new default gateway.

```text
root@deb64:~# ip route
default via 192.168.150.1 dev ens3 
192.168.150.0/24 dev ens3 proto kernel scope link src 192.168.150.2
```

Now we are done setting up the victim machine.

**Attacking machine**

First we need to give our machine the ip-address of the default gateway, so that the victim will connect to the attacking machine.

```text
ip addr add 192.168.150.1/24 dev ens3
```

Now we just need to configure the NATing.

```text
iptables -t nat -A POSTROUTING -j ACCEPT
```

This is all we have to do. If we now do a`curl icanhazip.com`from our victim machine, we can see the traffic flying by with tcpdump in our attacker-machine.

However, we might want to inspect the traffic in burp-suite, or some other proxy tool. In ordet to do that we can redirect specific traffic into our proxy with the help of our friend iptables.

```text
iptables -t nat -A PREROUTING -i ens3 -s 192.168.150.2 -p tcp -m tcp --dport 443 -j REDIRECT --to-ports 8080
iptables -t nat -A PREROUTING -i ens3 -s 192.168.150.2 -p tcp -m tcp --dport 80  -j REDIRECT --to-ports 8080
iptables -t nat -A PREROUTING -i ens3 -s 192.168.150.2 -p tcp -m tcp --dport 53  -j REDIRECT --to-ports 53
```

Now we just have to configure burp-suite a little bit.

Go to`Proxy > Options > Proxy Listeners > Edit > Binding > All interfaces`

Go to:`Proxy > Options > Proxy Listeners > Edit > Request handling > Support invisible proxy`

Now if you do the following from the victim machine:

```text
curl icanhazip.com
```

You will see the request in burp suite.

If you want to mitm windowsyou just need to change the ip and gateway to 192.168.15.2 and 192.168.150.1.

### Netstat - Find outgoing and incoming connections <a id="netstat---find-outgoing-and-incoming-connections"></a>

Netstat is a multiplatform tool. So it works on both mac, windows and linux.

```text
$ netstat -antlp
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 mymachine:domain        *:*                     LISTEN      -               
tcp        0      0 localhost:ipp           *:*                     LISTEN      -               
tcp        0      0 localhost:27017         *:*                     LISTEN      -               
tcp        0      0 localhost:mysql         *:*                     LISTEN      -               
tcp        0      0 192.168.0.15:44013      ec2-54-85-27-14.c:https ESTABLISHED 6604/slack --disabl
tcp        0      0 192.168.0.15:51448      ec2-50-16-193-3.c:https ESTABLISHED 3120/chrome     
tcp        0      0 192.168.0.15:43476      104.27.152.203:https    TIME_WAIT   -               
tcp        0      0 192.168.0.15:59380      149.154.175.50:https    ESTABLISHED 5068/Telegram   
tcp        0      0 192.168.0.15:53840      149.154.175.50:http     ESTABLISHED 5068/Telegram   
tcp        0      0 192.168.0.15:47158      176.32.99.76:https      ESTABLISHED 3120/chrome     
tcp        0      0 192.168.0.15:47161      176.32.99.76:https      ESTABLISHED 3120/chrome     
tcp        0      0 localhost:27017         localhost:44196         ESTABLISHED -               
tcp        0      0 192.168.0.15:46910      a104-114-242-25.d:https ESTABLISHED 3120/chrome     
tcp        0      0 localhost:44196         localhost:27017         ESTABLISHED 6903/node       
tcp        0      0 192.168.0.15:36280      cb-in-f101.1e100.:https ESTABLISHED 3120/chrome     
tcp        0      0 192.168.0.15:47160      176.32.99.76:https      ESTABLISHED 3120/chrome     
tcp        0      1 192.168.0.15:59285      149.154.175.50:https    LAST_ACK    -               
udp        0      0 *:35733                 *:*                                 -               
udp        0      0 mymachine:domain        *:*                                 -               
udp        0      0 *:bootpc                *:*                                 -               
udp        0      0 *:33158                 *:*                                 -               
udp        0      0 *:ipp                   *:*                                 -               
udp        0      0 *:mdns                  *:*                                 3120/chrome     
udp        0      0 *:mdns                  *:*                                 3120/chrome     
udp        0      0 *:mdns                  *:*                                 -               
udp        0      0 192.168.0.15:55065      ce-in-f189.1e100.:https ESTABLISHED 3120/chrome
```

A few interesting things to observe here is that my machine is using any port over 1024 to connect to the outside. So it is not like just because we communicate with https and connect to port 443 that we use that port on our machine. On our machine it can be any port \(over 1024\) and usually any port over 10000.

Find out what services are listening for connection on your machine  
Flags

```text
-a # All
-n # show numeric addresses
-p # show port
-t # tcp
```

```text
netstat -anpt
```

To easily check out what process is using lots of bandwidth you can use nethogs.

```text
sudo apt-get install nethogs
nethogs
```

Or you can use tcpdump, or iptables.

Every listening process of course has a PID, but unless you are root you can't might not see them all.

### Firewall - Iptables <a id="firewall---iptables"></a>

Iptables is a firewall tool in linux. A firewall is basically a tool that scans incoming and/or outgoing traffic. You can add rules to the iptables to filter for certain traffic.

#### Types of chains <a id="types-of-chains"></a>

So you can filter traffic in three different ways **input**, **forward**, and **output**. These are called three different chains.

**INPUT**  
This is for incoming connections. If someone wants to ssh into your machine. Or a web-server responds to your request.

**FORWARD**  
This chain is used for traffic that is not aimed at your machine. A router for example usually just passes information on. Most connections are just passing through. As you can see this will probably not be used so much on your machine, as a normal desktop or a server doesn't router that much traffic.

**OUTPUT**

This chain is used for outgoing traffic.

**Active rules**

To view your active rules you do

```text
iptables -L
# It will output something like this

Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
```

So as we can see the current policy is to accept all traffic in all directions.

If you for some reason has been tampering with the iptables and maybe fucked up. This is how you return it to the default setting, accepting all connections

```text
iptables --policy INPUT ACCEPT
iptables --policy OUTPUT ACCEPT
iptables --policy FORWARD ACCEPT
```

If you instead want to forbid all traffic you do

```text
iptables --policy INPUT DROP
iptables --policy OUTPUT DROP
iptables --policy FORWARD DROP
```

Okay, so let's block out some connections. To do that we want to add/append a new rule. We want to block all connections from our enemy 192.168.1.30.

```text
# A for append, and S for source. 
iptables -A INPUT -s 192.168.1.30 -j DROP
# Block an entire range
iptables -A INPUT -s 192.168.1.0/24 -j DROP
```

Now if we want to see our current rules we just do

```text
iptables -L
```

And we can now see our new rule.

To add line-numbers for each rule, so that you can then specify which rule you want to reset or change or something you can output the rluels with line-numbers

```text
iptables -L -v --line-numbers
```

**Remove/delete a rule**  
To remove a rule you just do

```text
# Remove one specific rule
iptables -D INPUT 2
# Remove all rules
iptables -F
```

**Save your changes**  
Your changes will only be saved and therefore in action until you restart iptables. So they will disappear every time you reboot unless you save the changes. To save the changes on ubuntu you do

```text
sudo /sbin/iptables-save
```

#### Measuring bandwidth usage <a id="measuring-bandwidth-usage"></a>

There are a few different tools in hour arsenal that we can use to measure bandwidth usage. We will start with iptables.

To view the input and output traffic we just list the rules with some verbosity.

```text
iptables -L -v
# Stdout
Chain INPUT (policy ACCEPT 6382 packets, 1900K bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 4266 packets, 578K bytes)
 pkts bytes target     prot opt in     out     source               destination
```

So clean this up and reset the count we can do the following

```text
# Restar the count
iptables -Z
# Remove all the rules, FLUSH them
iptables -F
```

So now we just need to add our rules. A simple script for this would be

```text
#!/bin/bash
iptables -F
iptables -I INPUT 1 -p tcp -j ACCEPT
```

Then check out the traffc with

```text
iptables -L -v --line-numbers
```

#### Examples <a id="examples"></a>

**Block outgoing connections to a specific ip**

```text
iptables -A OUTPUT -d 198.23.253.22 -j DROP
```

* Deny traffic to ports except for Local Loopback

  \`iptables -A INPUT -p tcp --destination-port 13327 ! -d $ip -j DROP \`

  \`iptables -A INPUT -p tcp --destination-port 9991 ! -d $ip -j DROP\`

* Clear ALL IPTables firewall rules

  ```text
  iptables -P INPUT ACCEPT

  iptables -P FORWARD ACCEPT

  iptables -P OUTPUT ACCEPT

  iptables -t nat -F

  iptables -t mangle -F

  iptables -F

  iptables -X

  iptables -t raw -F iptables -t raw -X
  ```

[https://www.digitalocean.com/community/tutorials/how-to-list-and-delete-iptables-firewall-rules](https://www.digitalocean.com/community/tutorials/how-to-list-and-delete-iptables-firewall-rules)

### Troubleshooting <a id="troubleshooting"></a>

#### Have you tried turning it on and off? <a id="have-you-tried-turning-it-on-and-off"></a>

I have had problems with the network-adapter not starting or something like that, on Ubuntu. You can try to restart the network manager if this happens:

```text
sudo service network-manager restart
```

#### Magical rfkill <a id="magical-rfkill"></a>

If for some reason the wifi is blocked you can unblock it \(or block it\) with rfkill.

```text
$ rfkill list
0: phy0: Wireless LAN
    Soft blocked: no
    Hard blocked: no
2: hci0: Bluetooth
    Soft blocked: no
    Hard blocked: no
```

To block or unblock the **phy0** from the example above you do:

```text
# Block
rfkill block 0
# Unblock
rfkill unblock 0
```

If there is a **hard block** it means that there is a physical switch on you machine that you need to switch off.

### DNS <a id="dns"></a>

Another rather messy area is DNS. The reason for this is that we have a few different players here,`/etc/resolv.conf`,`resolvconf`,`dnsmasq`and the dreaded`NetworkManager`.

## References <a id="references"></a>

[https://linuxjourney.com/](https://linuxjourney.com/)  
[https://github.com/jlevy/the-art-of-command-line](https://github.com/jlevy/the-art-of-command-line)

