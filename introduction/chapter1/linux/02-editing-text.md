# 03 - Editing text

First let's just clear out something about **standard streams**, or **I/O**-streams. Standard streams are the streams that are used to interact between the human computer-user and the machine. There are three standard streams: standard input \(stdin\), standard output \(stdout\), and standard error \(stderr\).The stdin stream can be seen as an abstractions of the real keyboard input. So when you issue a command/program that requires input the program does not read straight from the keyboard input, instead it reads from the file STDIN.

## Stdin <a id="stdin"></a>

Stdin is the data that gets inputed into the program. An example of a program that requires stdin data is`cp`. In order for the program to do anything it needs input data. For example`cp file1 copy_of_file1`. Here`file1`and`copy_of_file1`is the stdin.

So the default Stdin comes from the STDIN-file that is a text-file representation of the keyboard input. But often times we do not want to input stuff from the keyboard, sometimes we want to input something into a program that comes from another file. That is when we can use redirection symbol:`>`.

So an example could be`cat < my_text_file.txt`. The data from my\_text\_file.txt will now be used as input instead of the keyboard input. The file descriptor for **stdin** is: **0**

## Stdout <a id="stdout"></a>

Stdout is the data that get ouputed from the program. For example, when you use the command`cat file1`that data/text that gets outputed is the stdout The same with the program`ls`. Not all programs have stdout. For example when you use`mv`or`cp`successfully you get no stdout back from the program.

The stdout can be redirected to another file by using these symbols`>`and`>>`. So now we can do the following:

```text
ls >  result_of_ls.txt
# now the result will be written to the file result_of_ls.txt
ls >> result_of_ls.txt
# This will append the data to the bottom of the file result_of_ls.txt
```

Another incredibly useful feature is the**pipe**feature, reprsented with this symbol`|`. It will take the stdout and redirect it into another program. Here is an example:

```text
ls -la | less
```

This will take the stdout from`ls -la`and forward/redirect it into the`less`program. Using the **pipe** you can now chain different commands. The file descriptor for **stdout** is: **1**

## Stderr <a id="stderr"></a>

Stderr is the stream used for outputting error messages. So if a program fails for whatever reason. For example, if we try to copy a file that does not exist, this will be the stdrr output:

```text
cp thisfiledoesnotexist aaaaaaaaaa
cp: cannot stat 'thisfiledoesnotexist': No such file or directory
```

This is a common way for stderr to present itself, just straight out into the terminal. But sometimes stderr gets sent to a log file.

Stderr is useful because with it we can separate between**stdout**and**stderr**. However, to the eye it might be difficult to distinguish what output is**stdout**and what output is**stderr**.

One easy way to determine is the output is**stderr**or**stdout**is to simply redirect it into a file. Because by default you only redirect**stdout**, and not**stderr**.

```text
cp thisfiledoesnotexist aaaaaaaaaa >  result.txt
cp: cannot stat 'thisfiledoesnotexist' : No such file or directory

# If we now look at result.txt we will find that it is empty. Since the error-text we recieved
 could not be redirected into the textfile, since it is stderr and not stdout.
```

## Filters <a id="filters"></a>

There are certain programs that are especially useful to use together with pipes. They can also be used as stand-alone programs but you will often see them together with pipes.

`sort`

```text
sort test.txt
```

`uniq`

```text
sort -u test.txt
sort test.txt | uniq
cat filename | sort -u >  newFileName
```

`grep`Extract all the lines that contain a string````` grep "href=" index.html\`\`\`

`head`Get the start or end of a file

`tail`Get the end of a file

`wc index.html` Count numbers of lines in a file

`tr`

`sed`

## Editing text <a id="editing-text"></a>

Cut a string by a delimiter, filter results then sort

`grep "href=" index.html | cut -d "/" -f 3 | grep "\\." | cut -d '"' -f 1 | sort -u`

Using Grep and regular expressions and output to a file

`cat index.html | grep -o 'http://\[^"\]\*' | cut -d "/" -f 3 | sort â€“u > list.txt`

Collect all the IP Addresses from a log file and sort by frequency

`cat access.log | cut -d " " -f 1 | sort | uniq -c | sort -urn`

### sed <a id="sed"></a>

Can perform basic editing on streams, that is to say, text. Remove first line of file/stream

```text
sed "1d"
```

### cut <a id="cut"></a>

Cut by column This is a useful command to cut in text. Let's say that we have the following text, and we want to cut out the ip-address.

```text
64 bytes from 192.168.0.1: icmp_req=1 ttl=255 time=4.86 ms
```

```text
cut -d" " -f4
```

`-d`stands for delimiter. and`-f`for field.

### tr - Translate <a id="tr---translate"></a>

Transform all letter into capital letters

```text
tr "[:lower:]" "[:upper:]" < file1 > file2
```

Example Remove character

```text
# Remove characters
cat file.txt | tr -d "."

# Remove and replace
# Remove all dots and replace them with underscore.
cat file.txt | tr "." "_"
```

[http://www.thegeekstuff.com/2012/12/linux-tr-command/](http://www.thegeekstuff.com/2012/12/linux-tr-command/)

### awk <a id="awk"></a>

So awk is an advanced tool for editing text-files. It is its own programming language to it can become quite complex. Awk iterates over the whole file line by line. This is the basic structure of an awk command

```text
awk '/search_pattern/ { action_to_take_on_matches; another_action; }' file_to_parse
```

The search pattern takes regex. You can exclude the search portion or the action portion. This just prints every line of the file.

```text
awk '{print}' filename
```

Filtering out specific ip-address:

```text
awk '/172.16.40.10.81/' error.log
```

Now we want to print out the **fourth** column of that file, we can just pipe this to cut, but we can also use awk for it, like this:

```text
awk '/172.16.40.10.81/ {print $4}' error.log
# Another example
awk '{print $2,$5;}' error.txt
This prints columns 2 and 5.
```

We can use the -F flag to add a custom delimiter.

```text
awk -F ':' '{print $1}' test.txt
```

So if you are manipulating some text you might want to start the output with some info about the columns or something like that. To do that we can use the BEGIN-keyword.

```text
awk 'BEGIN {printf "IP-address \tPort\n"} /nop/ {print $3}' test.txt | head
awk 'BEGIN{printf "IP-address \tPort\n"} /nop/ {print $3} END {printf "End of the file\n"}' test.txt | tail
```

Here we are printing IP-address PORT to the first line of the file.

